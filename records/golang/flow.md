# 条件判断与函数

> 1. 条件判断之前加入变量应该是Go语言很强大的地方，x作用域就只在if之间

> 1. ```go
>   // 计算获取值x,然后根据x返回的大小，判断是否大于10。
>   if x := computedValue(); x > 10 {
>   fmt.Println("x is greater than 10")
>   } else {
>   fmt.Println("x is less than 10")
>   }
>   ```
>
> 2. 有没有发现，其实while就是for循环把第1个和第3个表达式给去掉了，所以golang索性去除掉了while关键字
>
> 3. 官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。
>
> 4. Go语言中`channel`，`slice`，`map`这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。
>
> 5. Go 语言的defer语句相当于是以栈的形式压入的，当执行完所有语句之后，再逆序执行defer语句
>
> 6. 在Go中函数也是一种变量，我们可以通过`type`来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型
>
> 7. Go语言不像Java一样，拥有异常处理机制，而是使用panic和recover成对使用，具体怎么用，暂时不管~
>
> 8. 一个项目中，最好只有一个main函数，一个package中，每个文件中，最好只有一个init函数，init函数和main函数都会自动加载
>
> 9. 引入包，import路径的2种方式，绝对路径和相对路径，推荐使用绝对路径；import写法的3种形式：
>
>    > a. `import (. "fmt")`: 可以直接使用fmt包里面的函数，而不需要加包名
>    >
>    > b. `import (f "fmt"):`fmt包取一个别名，叫做f
>    >
>    > c. `import (_ "fmt"):`这个只是引用fmt包中的init()函数，并不会使用fmt中的包
>
> 10. 当一个struct是在另一个struct在，是匿名时，相当于是一种继承关系了
>
> 11. Go语言知道我们要做的一切！？感觉Go语言是C++的一个升级
>
> 12. Go语言方法的继承居然是通过匿名字段的形式完成的
>
> 13. 空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值
>
> 14. 必须使用make来创建channel
>
> 15. 记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，也就是在被调函数处关闭它；channel不像文件之类的，不需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的才去关闭channel